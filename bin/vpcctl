#!/bin/bash

set -e  # Exit on any error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# State management
STATE_DIR="/etc/vpcctl"
STATE_FILE="$STATE_DIR/vpcs.json"

# Logging functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Check if running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        log_error "This script must be run as root (use sudo)"
        exit 1
    fi
}

# Initialize state file
init_state() {
    if [[ ! -d "$STATE_DIR" ]]; then
        mkdir -p "$STATE_DIR"
    fi
    if [[ ! -f "$STATE_FILE" ]]; then
        echo '{}' > "$STATE_FILE"
    fi
}

# Check if VPC exists
vpc_exists() {
    local vpc_name=$1
    init_state
    
    if command -v jq &> /dev/null; then
        jq -e --arg name "$vpc_name" '.[$name]' "$STATE_FILE" > /dev/null 2>&1
    else
        grep -q "\"$vpc_name\"" "$STATE_FILE" 2>/dev/null
    fi
}

# Save VPC state
save_vpc_state() {
    local vpc_name=$1
    local cidr=$2
    local bridge_name=$3
    
    init_state
    
    if command -v jq &> /dev/null; then
        local temp_file=$(mktemp)
        jq --arg name "$vpc_name" \
           --arg cidr "$cidr" \
           --arg bridge "$bridge_name" \
           '.[$name] = {
               "cidr": $cidr,
               "bridge": $bridge,
               "subnets": {},
               "created_at": (now | todate)
           }' "$STATE_FILE" > "$temp_file"
        mv "$temp_file" "$STATE_FILE"
    else
        # Fallback: simple append (not perfect but works)
        log_warning "jq not found, using basic state management"
        cat > "$STATE_FILE" <<EOF
{
  "$vpc_name": {
    "cidr": "$cidr",
    "bridge": "$bridge_name",
    "subnets": {},
    "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  }
}
EOF
    fi
    
    log_info "Saved VPC state: $vpc_name"
}

# Create VPC
create_vpc() {
    local vpc_name=""
    local cidr=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --name)
                vpc_name="$2"
                shift 2
                ;;
            --cidr)
                cidr="$2"
                shift 2
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    # Validate
    if [[ -z "$vpc_name" || -z "$cidr" ]]; then
        log_error "Missing required arguments"
        echo "Usage: vpcctl create --name <name> --cidr <cidr>"
        exit 1
    fi
    
    # Check if VPC already exists
    if vpc_exists "$vpc_name"; then
        log_error "VPC '$vpc_name' already exists"
        exit 1
    fi
    
    log_info "Creating VPC: $vpc_name with CIDR: $cidr"
    
    # Generate bridge name
    local bridge_name="br-${vpc_name}"
    
    # Extract gateway IP (first IP + 1)
    local gateway_ip=$(echo "$cidr" | awk -F'[./]' '{print $1"."$2"."$3"."($4+1)"/"$5}')
    
    # Create Linux bridge
    log_info "Creating bridge: $bridge_name"
    ip link add "$bridge_name" type bridge 2>/dev/null || {
        log_error "Failed to create bridge. It may already exist."
        exit 1
    }
    
    # Bring bridge up
    ip link set "$bridge_name" up
    
    # Assign IP to bridge
    ip addr add "$gateway_ip" dev "$bridge_name"
    
    log_info "✓ Bridge created: $bridge_name"
    log_info "✓ Gateway IP: $gateway_ip"
    
    # Enable IP forwarding
    sysctl -w net.ipv4.ip_forward=1 > /dev/null
    log_info "✓ IP forwarding enabled"
    
    # Save state
    save_vpc_state "$vpc_name" "$cidr" "$bridge_name"
    
    log_info "✓ VPC '$vpc_name' created successfully!"
    echo ""
    echo "Next steps:"
    echo "  1. List VPCs: sudo vpcctl list"
    echo "  2. Add subnets: sudo vpcctl add-subnet --vpc $vpc_name --name public --cidr 10.0.1.0/24"
}

# List VPCs
list_vpcs() {
    init_state
    
    log_info "Listing all VPCs"
    echo ""
    
    if [[ ! -s "$STATE_FILE" ]] || [[ "$(cat "$STATE_FILE")" == "{}" ]]; then
        echo "No VPCs found."
        echo "Create one with: sudo vpcctl create --name my-vpc --cidr 10.0.0.0/16"
        return
    fi
    
    # Print header
    printf "%-15s %-20s %-20s\n" "VPC NAME" "CIDR" "BRIDGE"
    printf "%-15s %-20s %-20s\n" "--------" "----" "------"
    
    # Simple parsing without jq
    if command -v jq &> /dev/null; then
        jq -r 'to_entries[] | "\(.key)|\(.value.cidr)|\(.value.bridge)"' "$STATE_FILE" | \
        while IFS='|' read -r name cidr bridge; do
            printf "%-15s %-20s %-20s\n" "$name" "$cidr" "$bridge"
        done
    else
        cat "$STATE_FILE"
    fi
}

# Delete VPC
delete_vpc() {
    local vpc_name=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --name)
                vpc_name="$2"
                shift 2
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [[ -z "$vpc_name" ]]; then
        log_error "Missing required argument: --name"
        exit 1
    fi
    
    if ! vpc_exists "$vpc_name"; then
        log_error "VPC '$vpc_name' does not exist"
        exit 1
    fi
    
    log_info "Deleting VPC: $vpc_name"
    
    local bridge_name="br-${vpc_name}"
    
    # Delete bridge
    if ip link show "$bridge_name" &> /dev/null; then
        ip link delete "$bridge_name"
        log_info "✓ Deleted bridge: $bridge_name"
    fi
    
    # Remove from state
    init_state
    if command -v jq &> /dev/null; then
        local temp_file=$(mktemp)
        jq --arg name "$vpc_name" 'del(.[$name])' "$STATE_FILE" > "$temp_file"
        mv "$temp_file" "$STATE_FILE"
    fi
    
    log_info "✓ VPC '$vpc_name' deleted successfully"
}
# Check if subnet exists
subnet_exists() {
    local vpc_name=$1
    local subnet_name=$2
    init_state
    
    if command -v jq &> /dev/null; then
        jq -e --arg vpc "$vpc_name" --arg subnet "$subnet_name" \
            '.[$vpc].subnets[$subnet]' "$STATE_FILE" > /dev/null 2>&1
    else
        grep -q "\"$subnet_name\"" "$STATE_FILE" 2>/dev/null
    fi
}

# Save subnet state
save_subnet_state() {
    local vpc_name=$1
    local subnet_name=$2
    local subnet_cidr=$3
    local subnet_type=$4
    local ns_name=$5
    local subnet_ip=$6
    
    init_state
    
    if command -v jq &> /dev/null; then
        local temp_file=$(mktemp)
        jq --arg vpc "$vpc_name" \
           --arg subnet "$subnet_name" \
           --arg cidr "$subnet_cidr" \
           --arg type "$subnet_type" \
           --arg ns "$ns_name" \
           --arg ip "$subnet_ip" \
           '.[$vpc].subnets[$subnet] = {
               "cidr": $cidr,
               "type": $type,
               "namespace": $ns,
               "ip": $ip,
               "created_at": (now | todate)
           }' "$STATE_FILE" > "$temp_file"
        mv "$temp_file" "$STATE_FILE"
    else
        log_warning "jq not found, state update limited"
    fi
    
    log_info "Saved subnet state: $subnet_name"
}
# Add subnet to VPC
add_subnet() {
    local vpc_name=""
    local subnet_name=""
    local subnet_cidr=""
    local subnet_type="private"  # default to private
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --vpc)
                vpc_name="$2"
                shift 2
                ;;
            --name)
                subnet_name="$2"
                shift 2
                ;;
            --cidr)
                subnet_cidr="$2"
                shift 2
                ;;
            --type)
                subnet_type="$2"
                shift 2
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    # Validate inputs
    if [[ -z "$vpc_name" || -z "$subnet_name" || -z "$subnet_cidr" ]]; then
        log_error "Missing required arguments"
        echo "Usage: vpcctl add-subnet --vpc <vpc-name> --name <subnet-name> --cidr <cidr> [--type public|private]"
        exit 1
    fi
    
    # Check if VPC exists
    if ! vpc_exists "$vpc_name"; then
        log_error "VPC '$vpc_name' does not exist"
        exit 1
    fi
    
    # Check if subnet already exists
    if subnet_exists "$vpc_name" "$subnet_name"; then
        log_error "Subnet '$subnet_name' already exists in VPC '$vpc_name'"
        exit 1
    fi
    
    log_info "Creating subnet '$subnet_name' in VPC '$vpc_name'"
    log_info "  CIDR: $subnet_cidr"
    log_info "  Type: $subnet_type"
    
    # Get VPC info
    local bridge_name="br-${vpc_name}"
    
    # Generate unique names for namespace and veth pair
    local ns_name="ns-${vpc_name}-${subnet_name}"
    local veth_host="veth-${vpc_name}-${subnet_name}-host"
    local veth_ns="veth-${vpc_name}-${subnet_name}-ns"
    
    # Extract IP for the namespace interface (first usable IP in subnet)
    local subnet_ip=$(echo "$subnet_cidr" | awk -F'[./]' '{print $1"."$2"."$3"."($4+2)"/"$5}')
    
    # Get gateway IP (the bridge IP)
    local gateway_ip=$(ip addr show "$bridge_name" | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)
    
    log_info "Creating network namespace: $ns_name"
    
    # Step 1: Create network namespace
    ip netns add "$ns_name" 2>/dev/null || {
        log_error "Failed to create namespace. It may already exist."
        exit 1
    }
    
    log_info "✓ Namespace created: $ns_name"
    
    # Step 2: Create veth pair
    log_info "Creating veth pair: $veth_host <-> $veth_ns"
    ip link add "$veth_host" type veth peer name "$veth_ns"
    
    # Step 3: Move one end of veth into the namespace
    ip link set "$veth_ns" netns "$ns_name"
    log_info "✓ Moved $veth_ns into namespace $ns_name"
    
    # Step 4: Connect host end to bridge
    ip link set "$veth_host" master "$bridge_name"
    log_info "✓ Connected $veth_host to bridge $bridge_name"
    
    # Step 5: Bring up host end of veth
    ip link set "$veth_host" up
    
    # Step 6: Configure namespace end
    # Bring up loopback interface in namespace
    ip netns exec "$ns_name" ip link set lo up
    
    # Bring up veth interface in namespace
    ip netns exec "$ns_name" ip link set "$veth_ns" up
    
    # Assign IP address in namespace
    ip netns exec "$ns_name" ip addr add "$subnet_ip" dev "$veth_ns"
    log_info "✓ Assigned IP $subnet_ip to $veth_ns in namespace"
    
    # Step 7: Set default route in namespace (gateway is the bridge)
    ip netns exec "$ns_name" ip route add default via "$gateway_ip"
    log_info "✓ Set default gateway to $gateway_ip"
    
    # Step 8: Save subnet state
    save_subnet_state "$vpc_name" "$subnet_name" "$subnet_cidr" "$subnet_type" "$ns_name" "$subnet_ip"
    
    log_info "✓ Subnet '$subnet_name' created successfully!"
    echo ""
    echo "Test connectivity:"
    echo "  Ping gateway: sudo ip netns exec $ns_name ping -c 3 $gateway_ip"
    echo "  Run command in subnet: sudo ip netns exec $ns_name <command>"
    echo ""
}
# Usage
usage() {
    cat << EOF
VPC Control Tool - Manage Virtual Private Clouds on Linux

Usage: vpcctl <command> [options]

Commands:
    create      Create a new VPC
    delete      Delete a VPC
    list        List all VPCs
    help        Show this help message

Examples:
    sudo vpcctl create --name dev-vpc --cidr 10.0.0.0/16
    sudo vpcctl list
    sudo vpcctl delete --name dev-vpc

EOF
}

# Main
check_root

COMMAND=$1
shift || true

case "$COMMAND" in
    create)
        create_vpc "$@"
        ;;
    delete)
        delete_vpc "$@"
        ;;
    list)
        list_vpcs "$@"
        ;;
    help|--help|-h|"")
        usage
        exit 0
        ;;
    *)
        log_error "Unknown command: $COMMAND"
        usage
        exit 1
        ;;
esac
